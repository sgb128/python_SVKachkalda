# Задача 1
# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти.

# в рамках домашнего задания к 6му уроку я буду исследовать функцию sum_nums и ее новые аналоги
# очень хотелось взять те задачи что я уже анализировал, но надо иногда побеждать свою лень матушку и написать
# все-таки пару строчек кода и для других задач.

# я надеюсь что меня никто не поругает если я просто пронумерую функции

# Я работаю под Windows 10(64)
# Ниже приведены данные о PyCharm'е с окна "О программе":
#
# PyCharm 2020.2.3 (Community Edition)
# Build #PC-202.7660.27, built on October 6, 2020
# Runtime version: 11.0.8+10-b944.34 amd64
# VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.
# Windows 10 10.0
# GC: ParNew, ConcurrentMarkSweep
# Memory: 974M
# Cores: 8
# Non-Bundled Plugins: mobi.hsz.idea.gitignore.

"""
Среди натуральных чисел, которые были введены, найти наибольшее по сумме цифр.
Вывести на экран это число и сумму его цифр.
"""
import sys


# имеющееся решение
def sum_nums1(x: int, sum_bytes=0):
    # мне стало интересно, сколько же объектов создается в рекурсивной функции? стоит ли их считать? я в общем... подсчитал
    # только вот на калькуляторе пришлось считать... пока я не сделаю рекурсию для второй переменной sum_bytes - не получается
    # в общем подсчета. Как только не пробовал. (все обращения к переменной sum_bytes я удалил, уж очень неуместно она
    # смотрится в коде) А если делать второй рекурсивный вызов - то ломается количество вызовов первой переменной и
    # подсчет неверный
    print(f'{type(x)=}, {id(x)=}, {sys.getsizeof(x)=}, {x=}')
    if x // 10 == 0:
        return x
    return x % 10 + sum_nums1(x // 10)
# передав число 1234 у меня получилось 42 байта (кстати ответ на главный вопрос...) заняла памяти рекурсивная функция...
# я ведь прав? стек вызовов никуда не девается
# соответственно подсчитанные "этажи" хранятся и ждут своего часа когда рекурсия заершится, а раз ждут - значит занимают место


# вариант через строку
def sum_nums2(x: str, sum_bytes=0):
    result = 0
    # здесь я сколняюсь к тому что надо подсчитать сами элементы, а не результат перевода их в целое число, так как это число
    # сразу же прибавляется к результату. Хотя я скорее всего ошибаюсь.
    for i in range(len(x)):
        result += int(x[i])
        sum_bytes += sys.getsizeof(x[i])
    sum_bytes += sys.getsizeof(result)
    return result, sum_bytes


# вариант через список(вариативно конечно же, но уповаю на умного пользователя)
def sum_nums3(lst: list, sum_bytes=0) -> int:
    result = 0
    for item in lst:
        result += int(item)
        sum_bytes += sys.getsizeof(item)
    sum_bytes += sys.getsizeof(result)
    return result, sum_bytes


num_max = 0
sum_max = 0
size_1 = 0
num = int(input('Введите натуральное число:'))
while num != 0:
    sum_n1 = sum_nums1(num)
    sum_n2, size_2 = sum_nums2(str(num))
    sum_n3, size_3 = sum_nums3(list(str(num)))
    # print(f'Для первой функции потребовалось памяти:{size_1}')
    print(f'Для второй функции потребовалось памяти:{size_2}')
    print(f'Для третьей функции потребовалось памяти:{size_3}')
    if sum_n1 > sum_max:
        num_max, sum_max = num, sum_n1
    num = int(input('Введите натуральное число:'))
print(f'Число с наибольшей суммой цифр: {num_max}, сумма его цифр составляет:{sum_max}')

# Вывод: все-таки рекурсивная функция оказалась самой экономной по занимаемой памяти
"""
Введите натуральное число:123

вот здесь кстати виден стек, как только рекурсия доходит до максимальной глубины - мы в один момент храним больше всего данных
соответственно весь объем памяти который выделяется под каждую переменную в каждом стеке нужно считать. По-моему так!)
type(x)=<class 'int'>, id(x)=1823321936, sys.getsizeof(x)=14, x=123
type(x)=<class 'int'>, id(x)=1823320160, sys.getsizeof(x)=14, x=12
type(x)=<class 'int'>, id(x)=1823319984, sys.getsizeof(x)=14, x=1
Для второй функции потребовалось памяти:92
Для третьей функции потребовалось памяти:92
Введите натуральное число:1234
type(x)=<class 'int'>, id(x)=23805360, sys.getsizeof(x)=14, x=1234
type(x)=<class 'int'>, id(x)=1823321936, sys.getsizeof(x)=14, x=123
type(x)=<class 'int'>, id(x)=1823320160, sys.getsizeof(x)=14, x=12
type(x)=<class 'int'>, id(x)=1823319984, sys.getsizeof(x)=14, x=1
Для второй функции потребовалось памяти:118
Для третьей функции потребовалось памяти:118
Введите натуральное число:12345
type(x)=<class 'int'>, id(x)=23805680, sys.getsizeof(x)=14, x=12345
type(x)=<class 'int'>, id(x)=23805504, sys.getsizeof(x)=14, x=1234
type(x)=<class 'int'>, id(x)=1823321936, sys.getsizeof(x)=14, x=123
type(x)=<class 'int'>, id(x)=1823320160, sys.getsizeof(x)=14, x=12
type(x)=<class 'int'>, id(x)=1823319984, sys.getsizeof(x)=14, x=1
Для второй функции потребовалось памяти:144
Для третьей функции потребовалось памяти:144
Введите натуральное число:123456
type(x)=<class 'int'>, id(x)=23805360, sys.getsizeof(x)=16, x=123456
type(x)=<class 'int'>, id(x)=23805504, sys.getsizeof(x)=14, x=12345
type(x)=<class 'int'>, id(x)=23804080, sys.getsizeof(x)=14, x=1234
type(x)=<class 'int'>, id(x)=1823321936, sys.getsizeof(x)=14, x=123
type(x)=<class 'int'>, id(x)=1823320160, sys.getsizeof(x)=14, x=12
type(x)=<class 'int'>, id(x)=1823319984, sys.getsizeof(x)=14, x=1
"""