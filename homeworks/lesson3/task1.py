# если осуществлять проверку непосредственно в функции где происходит вычисление результата, то при КАЖДОМ вызове функции
# в случае ошибок будут выводиться сообщения - грязный код получается, поэтому я вынес проверку в отдельную функцию
# и запрашиваю и проверяю параметры в ней. Так же избежал двойного кода проверки на каждый параметр вызвав вместо этого
# свою функцию
def f_division(p_divided: float, p_divider: float) -> float:
    """
    f_division позволяет получить частное разделив делимое(p_divided) на делитель(p_divider)
    :param p_divided: делимое может быть типом float или int
    :param p_divider: делитель может быть типом float или int
    :return: возвращает значение float
    """
    return p_divided / p_divider

def f_check_prompt(p_prompt: str = 'Введите число:') -> float:
    """
    f_check_prompt выполняет запрос данных у пользователя и проверяет является ли эти данные вещественным типом.
    В случае успеха - возвращает число типа float, в противном случае запрашивает ввод пока пользователь не введет
    число.
    :param p_prompt: строка, приглашение ко вводу
    :return:
    """
    while True:
        try:
            v_value = float(input(p_prompt))
            break
        except ValueError:
            print('Вы ввели не число! Повторите ввод!')
    return v_value


v_divided = f_check_prompt('Введите делимое:')
v_divider = f_check_prompt('Введите делитель:')
# зачем писать лишний код на проверку деления, если можно просто выполнить действие если второй аргумент не 0?
# проверка деления на 0 в 2 словах:
if v_divider:
    print(f_division(v_divided, v_divider))
else:  # ну и если все же ввели 0 - выводим сообщение. Возвращаем 'Not a number' иначе функция вернет None
    print('Нельзя просто так взять и разделить на 0! Ламповые компьютеры от этого даже взрывались.')
