# как из функции возвращать более 1-го объекта?
# слегка переписанная функция из 3го задания. Ну а чо? Зря писал что ли?
def f_greater(x: int, y: int):
    """
    f_greater определяет какое из 2-х значений больше
    :param x: int
    :param y: int
    :return: максимальное значение из 2х
    """
    v_set = {x, y}
    v_list = list(v_set)
    v_max = int(v_list[len(v_list) - 1])
    return v_max

def f_lower(x: int, y: int):
    """
    f_lower определяет какое из 2-х значений меньше
    :param x: int
    :param y: int
    :return: минимальное значение из 2х
    """
    v_set = {x, y}
    v_list = list(v_set)
    v_min = int(v_list[len(v_list) - 2])
    return v_min

def f_check_prompt(p_type: type = float, p_exception: str = 'Ошибочный ввод! Попробуйте еще раз!',  p_prompt: str = 'Введите число:') -> float:
    """
    f_check_prompt выполняет запрос данных у пользователя и проверяет является ли эти указанным типом v_type.
    В случае успеха - возвращает значение, в противном случае запрашивает ввод пока пользователь не введет значение верного типа.
    :param p_type: ссылка на функцию класса типа
    :param p_exception: строка, может быть вы захотите передать другое сообщение об ошибке
    :param p_prompt: строка, приглашение ко вводу
    :return:
    """
    while True:
        try:
            v_value = p_type(input(p_prompt))
            break
        except ValueError:
            print(p_exception)
    return v_value

def f_elevate(x: float, y: int):
    """
    f_elevate возводит X в степень Y
    :param x: вещественное число
    :param y: целое число
    :return: по возможности возвращает целое число
    """
    # запомним тип входного аргумента Х
    v_type = type(x)
    # запомним начальное значение аргумента Х
    v_res = x
    # возьмем наименьшее значение, чтобы знать в какую сторону нам потом приращивать переменную v_power
    v_power = f_lower(0, y)
    # запустим цикл от меньшего к большему включая большее число
    while v_power != f_greater(0, y)-1:
        # если степень была больше 0 то умножение, здесь 0 не включается
        if y > 0:
            v_res *= x
            v_power += 1
        # если степень меньше или равно 0 то деление
        # если, например, возвести 2 в степень 0 значит нам надо 2 разделить на себя 1 раз,
        # поэтому в это условие включается 0 степень
        else:
            if not v_res % x:
                v_res = v_type(v_res / x)
            else:
                v_res /= x
            v_power -= 1

    return v_res

# x = 2.0
# y = 0
# по условию задачи Х у нас вещественное положительное число, так что без зазрения совести говорю это интерпретатору
x = f_check_prompt(p_type = float, p_prompt = 'Введите вещественное число (x):')
# Y у нас по условию целое отрицательное
y = f_check_prompt(p_type = int, p_prompt = 'Введите целое число (y):')
# Знаки я решил опустить. Почему? Нет ничего сложного в том чтобы
# ограничить диапазон значений выше 0 или ниже, и в случае не соблюдения условия вывести ошибку.
# я же стремился к универсальности использования моей функции как делает то штатная, надеюсь, у меня получилось
print('Результат моей функции:', f_elevate(x, y))
# да, редактор подчеркивает "y" как вероятную ошибку, так как моя функция запроса данных универсальна и
# может вернуть отличный числовой тип от int, но так как я на входе передаю тип и проверяю его внутри у введенного
# числа, то хоть что введи, но пока не будет именно целого числа, то хоть в лепешку разбейся,
# моя функция не пропустит число иного типа
print('Результат штатного возведения в степень:', x**y)
# я не стал делать проверки типов внутри функции, хотя в случае использования ее без предварительной проверки,
# то в случае ввода строк будет ошибка, а в случае возведения числа в степень 0.5 будет неверный ответ.
